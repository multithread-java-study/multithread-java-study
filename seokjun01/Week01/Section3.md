# 1주차 - 섹션 4

## 스레드의 기본 정보

- 스레드를 생성할 때는 실행할 `Runnable` 인터페이스 구현체와 스레드 이름을 전달 가능
- `Thread` 클래스의 `toString()` 메서드는 스레드 ID, 이름, 우선순위, 스레드 그룹 정보를 포함한 문자열을 반환

---

## 체크 예외 재정의

- 메서드 재정의 시 지켜야 하는 예외 규칙:
    1. 상위 메서드가 예외를 던지지 않으면 하위 메서드도 정의하면 안됨
    2. 하위 메서드는 부모 메서드가 던질 수 있는 체크 예외의 **하위 타입만** 던질 수 있음

- 이유: 일관성을 유지하고 런타임 오류를 방지하기 위해
- `Runnable` 인터페이스는 예외를 던지지 않도록 설계되어 있음
    - 강제로 `try-catch`로 잡게 함으로써 **비정상 종료 방지**
    - 멀티스레드 환경에서 예외 처리 강제로 안정성과 일관성 유지

- **Tip**: `sleep()` 같은 체크 예외를 계속 처리하는 것이 번거롭다면, **유틸리티 메서드로 재활용** 가능

---

## Join의 시작

### join()을 통한 WAITING 상태란?

- 대기 상태: 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태
- 기본적으로 main 스레드는 새로운 스레드를 만들고 실행만 하고, 끝날 때까지 기다리지 않음
- **문제 상황**: main 스레드가 만든 스레드의 결과를 받아서 처리하고 싶다면?

---

### join이 필요한 상황

- 예제: 1~100까지 더하는 작업
    - 스레드 1개: 1~100까지 순차적으로 더함
    - 스레드 2개: 1~50, 51~100을 각각 계산 → 결과 합치면 처리 속도 2배
- 이때 main 스레드가 다른 스레드의 연산이 끝날 때까지 기다리려면 `join()` 사용

---

## `this`의 비밀

- 메서드 호출 = 특정 스레드가 메서드를 호출하는 것
- 인스턴스 메서드를 호출하면 어떤 인스턴스의 메서드인지 기억하기 위해 **해당 인스턴스의 참조값을 스택 프레임에 저장**
- 이 참조값이 바로 `this`

---

## Join - sleep vs join

- **Sleep 사용**
    - 특정 스레드를 기다리게 할 때 `sleep()`으로 연산 시간보다 더 기다리게 설정 가능
    - 정확한 타이밍 맞추기 어렵고, 반복문으로 상태 체크하면 번거로움

- **join 사용**
    - `Thread1.join()` 사용 시 main 스레드는 Thread1이 종료될 때까지 대기
    - 순차적으로 기다리려면:
      ```java
      Thread1.join();
      Thread2.join();
      ```
        - 각 스레드가 Terminated 상태가 될 때까지 순서대로 대기
    - **특정 시간만 대기** 가능: `join(ms)` 사용 → ms 시간만큼 기다리고, 스레드가 끝나지 않아도 계속 진행
