### Async 어노테이션하고 Thread 클래스의 관계

스프링부트에서는 메서드에 Async 어노테이션을 붙임으로써  
해당 기능을 새로운 쓰레드에서 실행시킴으로 비동기를 처리할 수 있습니다.  

이때 Async 어노테이션하고 직접 Thread를 생성하는 Thread 클래스는 어떤 관계가 있는지 궁금해서 정리해봤습니다.

---

#### 개념적 관계

Thread는 자바가 제공하는 가장 기본적인 실행 단위입니다.  

@Async는 스프링이 제공하는 선언적 비동기 처리 기능으로, 
개발자가 스레드를 직접 만들지 않아도 JVM에서 스레드를 만듦으로 비동기 실행이 가능합니다.

즉 @Async가 실행하는 메서드는 JVM의 실제 Thread 위에서 동작하며, 
스프링이 내부적으로 미리 만들어 둔 여러 개의 스레드를 재사용하는 방식인 스레드 풀을 이용해 Thread를 관리합니다.

---

#### 동작 흐름

먼저 클라이언트가 @Async가 붙은 메서드를 호출하면 스프링 AOP 프록시가 이 호출을 가로챕니다.  

프록시는 해당 메서드 실행을 Executor에 Runnable/Callable 형태로 제출합니다.  

Executor의 스레드 풀에 있는 Thread가 큐에서 작업을 꺼내 실행합니다.  
(현재 사용가능한 스레드가 없으면 대기상태로 들어갑니다.)

---

#### 언제 무엇을 쓸까?

##### @Async 사용

스프링 환경에서 단순히 메서드를 비동기로 돌리고 싶을 때

스레드 풀 관리, 예외 처리, 트랜잭션/보안 컨텍스트 전파 등을 스프링에 맡기고 싶을 때

대부분의 스프링 기반 애플리케이션에서 권장

##### Thread 직접 사용(new Thread)

스레드 생성·수명·우선순위 등을 세밀하게 직접 제어해야 하는 경우

라이브러리 레벨에서 프레임워크 의존 없이 멀티스레딩을 구현할 때

---

#### 결론

@Async는 스프링이 Thread를 직접 다루는 복잡함을 추상화해 주는 도구이며,  
내부적으로는 결국 Thread 풀을 사용해 비동기 실행을 실현해줍니다.  

스프링 프레임워크를 사용하는 서비스의 경우 @Async를 사용하는 것이 편리함을 주지만,  
java의 라이브러리를 구현하거나 순수 java를 쓰는 경우에는 Thread 클래스를 직접 사용해야하는 것 같습니다.
